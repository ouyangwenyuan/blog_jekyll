<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>持续学习者————Just Do It！</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="看，听，学，记，练；读，思，写，说，教。读书百遍，其义自现，熟能生巧，巧能升精，精能升华，华能出奇，出奇方能制胜。">
<meta property="og:type" content="website">
<meta property="og:title" content="持续学习者————Just Do It！">
<meta property="og:url" content="http://droidman.net/index.html">
<meta property="og:site_name" content="持续学习者————Just Do It！">
<meta property="og:description" content="看，听，学，记，练；读，思，写，说，教。读书百遍，其义自现，熟能生巧，巧能升精，精能升华，华能出奇，出奇方能制胜。">
<meta property="og:locale" content="en,ZH">
<meta property="article:author" content="OuyangWenyuan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="C">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="Objective-c">
<meta property="article:tag" content="Swift">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="Unity3d">
<meta property="article:tag" content="Shader">
<meta property="article:tag" content="Http">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="Blog">
<meta property="article:tag" content="Program">
<meta property="article:tag" content="Mac OS">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Unix">
<meta property="article:tag" content="Window">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Lua">
<meta property="article:tag" content="Javascript">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="xcode">
<meta property="article:tag" content="IDEA">
<meta property="article:tag" content="eclicpse">
<meta property="article:tag" content="blender">
<meta property="article:tag" content="MVC">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="持续学习者————Just Do It！" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">持续学习者————Just Do It！</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">学无止境————不怕你不会，就怕你不学！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://droidman.net"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2017-04-16" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/2017-04-16/" class="article-date">
  <time datetime="2017-04-16T00:34:20.000Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/2017-04-16/">编程中的基本数据结构与算法思想</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h6 id="编程的关键在于选择数据结构和算法，数据结构用于描述问题，算法用于描述解决问题的方法和步骤。"><a href="#编程的关键在于选择数据结构和算法，数据结构用于描述问题，算法用于描述解决问题的方法和步骤。" class="headerlink" title="编程的关键在于选择数据结构和算法，数据结构用于描述问题，算法用于描述解决问题的方法和步骤。"></a>编程的关键在于选择数据结构和算法，数据结构用于描述问题，算法用于描述解决问题的方法和步骤。</h6><p>描述问题的数据除了各数据元素本身，还要考虑各元素的逻辑关系，主要是一对一的线性关系，一对多的树型关系和多对多的图形关系。另外，内存中对各数据元素的存储只有顺序存储和链式存储两种方式，所以数据结构还要考虑数据的存储结构，并考虑逻辑结构与数据结构如何有效地结合到一起。</p>
<h6 id="用算法描述问题，当问题比较复杂时，通常的思路是分而治之，并辅以适当的数据结构。"><a href="#用算法描述问题，当问题比较复杂时，通常的思路是分而治之，并辅以适当的数据结构。" class="headerlink" title="用算法描述问题，当问题比较复杂时，通常的思路是分而治之，并辅以适当的数据结构。"></a>用算法描述问题，当问题比较复杂时，通常的思路是分而治之，并辅以适当的数据结构。</h6><h5 id="1-分治法Divide-and-Conquer"><a href="#1-分治法Divide-and-Conquer" class="headerlink" title="1 分治法Divide and Conquer"></a>1 分治法Divide and Conquer</h5><p>分治法通常描述为以下三步：</p>
<ol>
<li><p>Divide the problem into more subproblems（分解问题为众多的子问题）;</p>
</li>
<li><p>Conuqe(solve) the subproblems（解决各子问题）;</p>
</li>
<li><p>Combine(merge) the solution of subproblems(if need)（合并各子问题的解（如果需要））.</p>
</li>
</ol>
<p>如用分治法来计算2^10?</p>
<p>2^10＝2^5<em>x^5=2^2</em>x^3<em>x^5=32</em>32=1024</p>
<p>相对于顺序查找，二分查找有更高的效率，前提是二分查找需要事先排好序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearchLoop</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len, <span class="keyword">int</span> findData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr==<span class="literal">NULL</span> || len &lt;=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">end</span> = len<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(start&lt;=<span class="built_in">end</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = start+(<span class="built_in">end</span>-start)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] == findData)</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(findData &lt; arr[mid])</span><br><span class="line">      <span class="built_in">end</span> = mid<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      start = mid+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-枚举法也是一种暴力缩小问题规模的算法"><a href="#2-枚举法也是一种暴力缩小问题规模的算法" class="headerlink" title="2 枚举法也是一种暴力缩小问题规模的算法"></a>2 枚举法也是一种暴力缩小问题规模的算法</h5><p> <br>简单的枚举算法也是可以优化的，即尽可能缩小搜索的空间，如判断质数：</p>
<blockquote>
<p>质数（prime number）又称素数，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。</p>
</blockquote>
<p>判断质数的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;= <span class="number">1</span>)<span class="comment">// 小于等于1的整数不可能是素数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">2</span>); <span class="comment">// 2 是素数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>); <span class="comment">// 能被2整除的其他整数都不是素数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> limit = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>((<span class="keyword">double</span>)n)+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= limit; i=i+<span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="number">1.</span> 只要发现任何一个大于<span class="number">1</span>小于n的因子，就能停下来报告n不是素数。</span><br><span class="line"> <span class="number">2.</span> 如果n能被<span class="number">2</span>整除，直接报告n不是素数。如果n不能被<span class="number">2</span>整除，那么它也不可能被<span class="number">4</span>或<span class="number">6</span>或其他偶数整除。因此，isPrime只需要检查<span class="number">2</span>和奇数（由<span class="number">3</span>开始，步长为<span class="number">2</span>）。但注意有个特例，<span class="number">2</span>能被<span class="number">2</span>整除，但<span class="number">2</span>是素数。</span><br><span class="line"> <span class="number">3.</span> 如果n不是素数，则必有一个因子小于√n 。因此不需要检查到n为止。只需检查到√n（n=√n*√n） 。</span><br></pre></td></tr></table></figure>
<p>因为如果n能被2~n-1之间任一整数整除，其二个因子必定有一个小于或等于√n，另一个大于或等于√n。例如24可以表示为：2<em>12、3</em>8、4*6，前面的因子小于√24，后面的因子大于√24，检验出了小因子，即可判断n是否为素数，就像逻辑运算的短路求值。
 </p>
<h5 id="3-程序的模块化"><a href="#3-程序的模块化" class="headerlink" title="3 程序的模块化"></a>3 程序的模块化</h5><p> <br>分治法在程序思想中的应用就是实现程序的模块化，包括面向过程的函数化和面向对象的对象化。 <br> <br>许多原因都促使我们将应用程序分解成函数，下面仅列举其中三个：<br> <br>函数一般小而具体。用一系列函数来写程序，胜于一气呵成写完整个程序。这称为“分而治之”，使你的精力一次集中在一个函数上。<br> <br>包含许多小函数的应用程序比单一的长程序更容易阅读和调试。<br> <br>函数可以重用。函数写好后可在程序的其他任何地方调用。这减少了编码量，提高了开发效率。 
 </p>
<h5 id="4-函数调用与栈"><a href="#4-函数调用与栈" class="headerlink" title="4 函数调用与栈"></a>4 函数调用与栈</h5><p> <br>首先讨论一个从a点出发去f点，然后回到a点的问题（中间的b、c、d、e都有多个分岔口）：<br> <br>a→b2→c1→d3→e2→f，每个分岔口都有一个信封，告诉你应该走哪一个分支，为了能够正确地回到起点a，正确的做法是拿到一个信封后，即将这个信封叠在上一次拿到的信封的上面，回去时，依次从上面拿取信封，按提示即可正确返回。 <br> <br>其做法就是依次放入，依次取出，信封之间是顺序关系，只在一端操作，也就是不管是放入还是取出都不在中间操作。这样一种思路在计算机上用数据来描述就是后进先出的栈，函数的调用、返回，递归、回溯算法都需要使用栈这种数据结构（由程序员或递归时由编译器来实现）。<br> <br>在C++中，函数不能嵌套定义，但可以嵌套调用，在函数调用时，编译器需要确保在逐级调用后能够回归到最初的调用点，编译器会隐式实现一个堆栈，用来保存每一级函数调用时的函数返回地址和局部变量，依次入栈和出栈。<br> <br>C++也支持递归函数的递归调用，同样是由编译器隐式地实现了一个堆栈。
 </p>
<h5 id="5-深度搜索与广度搜索"><a href="#5-深度搜索与广度搜索" class="headerlink" title="5 深度搜索与广度搜索"></a>5 深度搜索与广度搜索</h5><p> <br>如果将上述的问题稍微扩展一点，要从源点到目标点，中间的节点可能有多个分叉，这样的问题可以用一个树或图来描述。<br>而探路的方法可以分为两种，一种是深度优先搜索（下一点、下一点……回溯……），一种是广度优先搜索（下一点的全部分叉、下一点的全部分叉……）：
 </p>
<ol>
<li><p>深度优先搜索用栈（stack）来实现，整个过程可以想象成一个倒立的树形：</p>
<p> 1）把根节点压入栈中。<br> 2）每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱。<br> 3）找到所要找的元素时结束程序。<br> 4）如果遍历整个树还没有找到，结束程序。</p>
</li>
<li><p>广度优先搜索使用队列（queue）来实现，整个过程也可以看做一个倒立的树形：</p>
<p> 1）把根节点放到队列的末尾。<br> 2）每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱。（取出的元素也可以保存到一个队列）<br> 3）找到所要找的元素时结束程序。<br> 4）如果遍历整个树还没有找到，结束程序。</p>
</li>
</ol>
<h5 id="6-递归算法"><a href="#6-递归算法" class="headerlink" title="6 递归算法"></a>6 递归算法</h5><p> <br>递归就是某个函数直接或间接的调用自身。<br>语法形式上: 在一个函数的运行过程中, 调用这个函数自己：</p>
<blockquote>
<p>直接调用: 在fun()中直接执行fun()；<br>间接调用: 在fun1()中执行fun2(); 在fun2()中又执行fun1() ；</p>
</blockquote>
<p>问题的求解过程是划分成许多相同性质的子问题的求解，而小问题的求解过程可以很容易的求出。这些子问题的解就构成里原问题的解。<br> <br>待求解问题的解可以描述为输入变量x的函数f(x)。 <br> <br>通过寻找函数g( )，使得f(x) = g(f(x-1))。<br> <br>且已知f(0)的值, 就可以通过f(0)和g( )求出f(x)的值。<br> <br>扩展到多个输入变量x, y, z等, x-1也可以推广到 x - x1 , 只要递归朝着 “出口” 的方向即可。<br> <br>递归算法分解出的子问题与原问题之间是纵向的, 同类的关系（枚举分解出的子问题之间是横向的, 同类的关系）。<br> <br>递归的三个要点:</p>
<ul>
<li>递归式：如何将原问题划分成子问题；</li>
<li>递归出口：递归终止的条件, 即最小子问题的求解,可以允许多个出口；</li>
<li>界函数：问题规模变化的函数, 它保证递归的规模向出口条件靠拢。</li>
</ul>
<p>如一个求阶乘的递归程序，给定n, 求阶乘n!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> n,m=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n; i++)</span><br><span class="line">	m *=i;</span><br><span class="line">	</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> n * factorial(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分搜索的递归实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearchRecursion</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> findData, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr==<span class="literal">NULL</span> || start&gt;<span class="built_in">end</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start+(<span class="built_in">end</span>-start)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] == findData)</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(findData &lt; arr[mid])</span><br><span class="line">      binarySearchRecursion(arr, findData, start, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      binarySearchRecursion(arr, findData, mid+<span class="number">1</span>, <span class="built_in">end</span>);</span><br></pre></td></tr></table></figure>


<h5 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7 归并排序"></a>7 归并排序</h5><p> <br>归并排序（merge sort）是建立在归并操作上的一种有效的排序算法。该算法是分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并（2-way or binary merges sort）。 <br> <br>归并排序在1945年由冯·诺伊曼首次提出。<br> <br>2-路归并的基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序？<br> <br>可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。 <br> <br>归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N<em>logN)。因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在O(N</em>logN)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。<br> <br>归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。<br> <br>7.1 归并排序分解</p>
<p>可以看到这种结构很像一棵完全二叉树，分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</p>
<p>7.2 归并排序合并相邻有序子序列<br> <br>再来看看并阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。<br> <br>    •    申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； <br>    •    设定两个指针，最初位置分别为两个已经排序序列的起始位置； <br>    •    比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++]; <br>    •    重复步骤3直到某一指针到达序列尾； <br>    •    将另一序列剩下的所有元素直接复制到合并序列尾;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"><span class="comment">// 合并两个已排好序的数组A[left...mid]和A[mid+1...right]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[len]; <span class="comment">// 辅助空间O(n)</span></span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = left; <span class="comment">// 前一数组的起始元素</span></span><br><span class="line">  <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">// 后一数组的起始元素</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)</span><br><span class="line">  &#123;</span><br><span class="line">    temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++]; <span class="comment">// 带等号保证归并排序的稳定性</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">  &#123;</span><br><span class="line">    temp[index++] = A[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">  &#123;</span><br><span class="line">    temp[index++] = A[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++)</span><br><span class="line">  &#123;</span><br><span class="line">    A[left++] = temp[k];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现的归并排序(自顶向下)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortRecursion</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left == right) <span class="comment">// 当待排序的序列长度为1时，递归开始回溯，进行merge操作</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">  MergeSortRecursion(A, left, mid); <span class="comment">//左半部分排好序</span></span><br><span class="line">  MergeSortRecursion(A, mid + <span class="number">1</span>, right); <span class="comment">//右半部分排好序</span></span><br><span class="line">  Merge(A, left, mid, right); <span class="comment">//合并左右部分</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归(迭代)实现的归并排序(自底向上)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortIteration</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> left, mid, right;<span class="comment">// 子数组索引,前一个为A[left...mid]，后一个子数组为A[mid+1...right]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i *= <span class="number">2</span>) <span class="comment">// 子数组的大小i初始为1，每轮翻倍</span></span><br><span class="line">  &#123;</span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + i &lt; len) <span class="comment">// 后一个子数组存在(需要归并)</span></span><br><span class="line">    &#123;</span><br><span class="line">      mid = left + i - <span class="number">1</span>;</span><br><span class="line">      right = mid + i &lt; len ? mid + i : len - <span class="number">1</span>;<span class="comment">// 后一个子数组大小可能不够</span></span><br><span class="line">      Merge(A, left, mid, right);</span><br><span class="line">      left = right + <span class="number">1</span>; <span class="comment">// 前一个子数组索引向后移动</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> A1[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;; <span class="comment">// 从小到大归并排序</span></span><br><span class="line">  <span class="keyword">int</span> A2[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line">  <span class="keyword">int</span> n1 = <span class="keyword">sizeof</span>(A1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> n2 = <span class="keyword">sizeof</span>(A2) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">  MergeSortRecursion(A1, <span class="number">0</span>, n1 - <span class="number">1</span>); <span class="comment">// 递归实现</span></span><br><span class="line">  MergeSortIteration(A2, n2); <span class="comment">// 非递归实现</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"递归实现的归并排序结果："</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, A1[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"</span></span><br><span class="line"><span class="string">    "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"非递归实现的归并排序结果："</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n2; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, A2[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"</span></span><br><span class="line"><span class="string">    "</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> </p>
<h5 id="8-回溯法和分书问题"><a href="#8-回溯法和分书问题" class="headerlink" title="8 回溯法和分书问题"></a>8 回溯法和分书问题</h5><p> <br>回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯“返回，尝试别的路径。可以参考一下走迷宫的过程，一开始会随机选择一条道路前进，一直到走不通之后就会回头直到找到另外一条没有试过的道路前进。实际上，走迷宫的算法就是回溯法的经典问题。<br> <br>回溯法实际上也是一种试错的思路，通过不断尝试解的组合来达到求解可行解和最优解的目的。虽然都有穷搜的概念蕴含其中，但是回溯法和穷举查找法是不同的。对于一个问题的所有实例，穷举法注定都是非常缓慢的，但应用回溯法至少可以期望对于一些规模不是很小的实例，计算机在可接受的时间内对问题求解。<br> <br>许多复杂的规模的问题都可以使用回溯法，有”通用解题方法”的美称。分书问题和八皇后都是典型的回溯法问题。<br> <br>分书问题能够较有代表性地表现数据描述、递归、回溯的算法思路。 <br> <br>有编号为0，1，2，3，4的5本书，准备分给5个人A，B，C，D，E，写一个程序，输出所有皆大欢喜的分书方案。<br> <br>每个人的阅读兴趣用一个二维数组like描述： <br> <br>Like[i][j] = true i喜欢书j<br>Like[i][j] = false i不喜欢书j</p>
<p>设计一个函数trynext(int i)给第i个人分书。<br> <br>用一个一维数组take表示某本书分给了某人。take[j]=i+1;//把第j本书分配给第i个人<br> <br>依次尝试把书j分给人i。 <br> <br>如果第i个人不喜欢第j本书，则尝试下一本书，如果喜欢，并且第j本书尚未分配，则把书j分配给i。<br> <br>如果i是最后一个人，则方案数加1，输出该方案。否则调用trynext(i+1)为第i+1个人分书。<br> <br>如果对第i个人枚举了他喜欢的所有的书，都没有找到可行的方案，那就回到前一个状态i-1，让i-1把分到的书退回去，重新找喜欢的书，再递归调用函数，寻找可行的方案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> like[<span class="number">5</span>][<span class="number">5</span>]=&#123;</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> take[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//记录每一本书的分配情况</span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//n表示分书方案数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trynext</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="number">0</span>;</span><br><span class="line">	trynext(<span class="number">0</span>);</span><br><span class="line">	getch();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对第 i 个人进行分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trynext</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j,k;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(like[i][j]&amp;&amp;take[j]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			take[j]=i+<span class="number">1</span>;<span class="comment">//把第j本书分配给第i个人</span></span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">4</span>)<span class="comment">//第5个人分配结束，也即所有的书已经分配完毕，可以将方案进行输出</span></span><br><span class="line">			&#123;</span><br><span class="line">				n++;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;n&lt;&lt;<span class="string">"种分配方案"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;k&lt;&lt;<span class="string">"本书分配给"</span>&lt;&lt;(<span class="keyword">char</span>)(take[k]+<span class="string">'A'</span><span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			trynext(i+<span class="number">1</span>);<span class="comment">//递归，对下一个人进行分配</span></span><br><span class="line">			take[j]=<span class="number">0</span>;<span class="comment">//回溯，寻找下一种方案</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/04/16/2017-04-16/" data-id="cj1k4sbjs0000ep73bmhn9pry" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-15" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/15/2017-04-15/" class="article-date">
  <time datetime="2017-04-15T12:34:35.000Z" itemprop="datePublished">2017-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/15/2017-04-15/">MySQL面试题总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-为什么要使用数据库"><a href="#1-为什么要使用数据库" class="headerlink" title="1. 为什么要使用数据库 "></a>1. 为什么要使用数据库 </h4><pre><code>▪    数据保存在内存
    优点：存取速度快
    缺点：数据不能永久保存
▪    数据保存在文件
    优点：数据永久保存
    缺点：
        1）速度比内存操作慢，频繁的IO操作。
        2）查询数据不方便
▪    数据保存在数据库
    1）数据永久保存
    2）使用SQL语句，查询方便效率高。
    3）管理数据方便</code></pre><h4 id="2-什么是SQL？"><a href="#2-什么是SQL？" class="headerlink" title="2. 什么是SQL？"></a>2. 什么是SQL？</h4><p>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。<br>作用：用于存取数据、查询、更新和管理关系数据库系统。</p>
<h4 id="3-什么是MySQL"><a href="#3-什么是MySQL" class="headerlink" title="3. 什么是MySQL?"></a>3. 什么是MySQL?</h4><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p>
<h4 id="4-数据库三大范式是什么"><a href="#4-数据库三大范式是什么" class="headerlink" title="4. 数据库三大范式是什么"></a>4. 数据库三大范式是什么</h4><p>第一范式：每个列都不可以再拆分。<br>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。<br>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。<br>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p>
<h4 id="5-mysql有关权限的表都有哪几个"><a href="#5-mysql有关权限的表都有哪几个" class="headerlink" title="5. mysql有关权限的表都有哪几个"></a>5. mysql有关权限的表都有哪几个</h4><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p>
<pre><code>•    user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。 
•    db权限表：记录各个帐号在各个数据库上的操作权限。 
•    table_priv权限表：记录数据表级的操作权限。 
•    columns_priv权限表：记录数据列级的操作权限。 
•    host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。 </code></pre><h4 id="6-MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#6-MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="6. MySQL的binlog有有几种录入格式？分别有什么区别？"></a>6. MySQL的binlog有有几种录入格式？分别有什么区别？</h4><p>有三种格式，statement，row和mixed。</p>
<pre><code>•    statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。 
•    row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。 
•    mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。 </code></pre><p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p>
        
          <p class="article-more-link">
            <a href="/2017/04/15/2017-04-15/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/04/15/2017-04-15/" data-id="cj1ixu7ev000raa737ulk3y1x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-09" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/09/2017-04-09/" class="article-date">
  <time datetime="2017-04-09T00:33:58.000Z" itemprop="datePublished">2017-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/09/2017-04-09/">MySQL常用优化指南，及大表优化思路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当MySQL单表记录数过大时，增删改查性能都会急剧下降</p>
<h3 id="单表优化"><a href="#单表优化" class="headerlink" title="单表优化"></a>单表优化</h3><p>除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。<br>而事实上很多时候 MySQL 单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量。</p>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><pre><code>▪    尽量使用 TINYINT、 SMALLINT、 MEDIUM_INT 作为整数类型而非 INT，如果非负则加上 UNSIGNED 
▪    VARCHAR 的长度只分配真正需要的空间 
▪    使用枚举或整数代替字符串类型 
▪    尽量使用 TIMESTAMP 而非 DATETIME 
▪    单表不要有太多字段，建议在 20 以内 
▪    避免使用 NULL 字段，很难查询优化且占用额外索引空间 
▪    用整型来存 IP</code></pre>
        
          <p class="article-more-link">
            <a href="/2017/04/09/2017-04-09/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/04/09/2017-04-09/" data-id="cj1ac3djl0000aa738tgi53e9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-08" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/08/2017-04-08/" class="article-date">
  <time datetime="2017-04-08T00:41:04.000Z" itemprop="datePublished">2017-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/08/2017-04-08/">MySQL 学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="连接与断开服务器"><a href="#连接与断开服务器" class="headerlink" title="连接与断开服务器"></a>连接与断开服务器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 地址 -P 端口 -u 用户名 -p 密码</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCESSLIST</span> <span class="comment">-- 显示哪些线程正在运行</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="comment">-- 显示系统变量信息</span></span><br></pre></td></tr></table></figure>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前数据库</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>();</span><br><span class="line"><span class="comment">-- 显示当前时间、用户名、数据库版本</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">now</span>(), <span class="keyword">user</span>(), <span class="keyword">version</span>();</span><br><span class="line"><span class="comment">-- 创建库</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span>[ <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 数据库选项</span><br><span class="line">    数据库选项：</span><br><span class="line">        <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> charset_name</span><br><span class="line">        <span class="keyword">COLLATE</span> collation_name</span><br><span class="line"><span class="comment">-- 查看已有库</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>[ <span class="keyword">LIKE</span>  PATTERN ]</span><br><span class="line"><span class="comment">-- 查看当前库信息</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> 数据库名</span><br><span class="line"><span class="comment">-- 修改库的选项信息</span></span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> 库名 选项信息</span><br><span class="line"><span class="comment">-- 删除库</span></span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">DATABASE</span>[ <span class="keyword">IF</span> <span class="keyword">EXISTS</span>] 数据库名</span><br><span class="line">        同时删除该数据库相关的目录及其目录内容</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2017/04/08/2017-04-08/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/04/08/2017-04-08/" data-id="cj18w8n9z000065736kr96qzi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/02/2017-04-02/" class="article-date">
  <time datetime="2017-04-02T00:35:10.000Z" itemprop="datePublished">2017-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/02/2017-04-02/">Java 基础学习总结和学习路线规划</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>工作也有一段时间了，今天休息，正好有时间把最近所学的东西整理一下。<br>java是一门面向对象编程的语言，不仅吸收了c++语言的各种优点，还摒弃了c++中难以理解的多继承，指针等概念，作为静态面向对象语言编程代表，极好地实现了面向对象理论，让程序员以抽象的思维方式进行复杂的编程。<br>java语言的主要特点：<br>简单性<br>java不支持goto语句，代之以提供break和coninue语句以及异常处理，java还剔除了c++的操作符重载和多继承特征，java没有结构体，所有的数据都是对象，数组和字符串也是，所以不需要指针，java能够自动的处理对象的引用和间接引用，实现自动化的无用单元收集（自动垃圾回收GC），使程序不用为存储问题烦恼，把更多的时间和精力花在处理业务。<br>面向对象<br>封装，继承，多态，<br>在一个面向对象的系统中，类（class）是数据和操作数据的方法的集合，数据和方法一起描述对象（object）的状态和行为，每一个对象是其行为和状态的封装，类是按一定体系和层次来安排的，子类可以从父类中继承行为。java程序是用类和包来组织的。包是类的扩展集合，<br>分布性<br>java设计成支持在网络上应用，它是分布式语言，支持各种层次的网络连接，java的socket类支持可靠的流网络连接，所以用户可以生产分布式的客户机和服务器，网络变成类软件应用的分布运载工具，java只需编写一次，就可以到处运行。<br>编译和解释性<br>java编译程序生成字节码（bytecode）而不是通常的机器码，java字节码提供对体系结构中性的目标文件格式，java程序可以在任何实现了java解释程序和运行环境（JRE）的系统中运行。在java虚拟机环境中，程序开发的标准链接阶段，java只是把新类装进环境的过程，它是增量式，轻量级的过程。<br>稳健性<br>java原来是被用来编写嵌入式系统软件的强类型语言，它允许扩展编译时检查潜在的类型不匹配问题，java要求显式的类型声明，不支持c风格的隐式声明，这些严格的要求保证类编译程序能捕捉调用错误，<br>java的存储模型，java不支持指针，它消除了重写存储和覆盖数据的可能性，java的垃圾回收机制能有效预防内存泄漏和其他有关动态存储分配和内存释放的错误。java解释程序也只需许多运行时的检查，比如空指针，数组越界等异常。说到这，java的异常处理也使得java程序更稳健的，使用try/catch/finally 语句，程序很容易定位出错的代码，大大简化了错误的处理和恢复任务。<br>安全性<br>java的存储分配模型是预防恶意代码的主要方法之一<br>可移植性<br>java程序是运行在java虚拟机中或者JRE中，java的编译程序也是用java编写的，而java的运行环境是用ANSI C编写的。sun公司提供了不同的操作系统java虚拟机（java运行环境）</p>
        
          <p class="article-more-link">
            <a href="/2017/04/02/2017-04-02/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/04/02/2017-04-02/" data-id="cj10327vt00009773foebhsn1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/01/2017-04-01/" class="article-date">
  <time datetime="2017-04-01T13:28:45.000Z" itemprop="datePublished">2017-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/01/2017-04-01/">Markdown 语法使用说明</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Markdown 语法和 MWeb 写作使用说明<br>Markdown 的设计哲学<br>本文约定<br>标题<br>第一级标题 <h1><br>第二级标题 <h2><br>第六级标题 <h6><br>强调<br>换行<br>列表<br>无序列表<br>有序列表<br>任务列表（Task lists）<br>图片<br>链接<br>区块引用<br>行内代码<br>多行或者一段代码<br>顺序图或流程图<br>表格<br>删除线<br>分隔线<br>MathJax<br>脚注（Footnote）<br>注释和阅读更多<br>TOC</p>
<h1 id="Markdown-语法和-MWeb-写作使用说明"><a href="#Markdown-语法和-MWeb-写作使用说明" class="headerlink" title="Markdown 语法和 MWeb 写作使用说明"></a>Markdown 语法和 MWeb 写作使用说明</h1><h2 id="Markdown-的设计哲学"><a href="#Markdown-的设计哲学" class="headerlink" title="Markdown 的设计哲学"></a>Markdown 的设计哲学</h2><blockquote>
<p>Markdown 的目標是實現「易讀易寫」。<br>不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。<br>Markdown 的語法有個主要的目的：用來作為一種網路內容的<em>寫作</em>用語言。</p>
</blockquote>
        
          <p class="article-more-link">
            <a href="/2017/04/01/2017-04-01/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/04/01/2017-04-01/" data-id="cj0zau2p100003s738mkua1fj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/mysql/" style="font-size: 20px;">mysql</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/04/16/2017-04-16/">编程中的基本数据结构与算法思想</a>
          </li>
        
          <li>
            <a href="/2017/04/15/2017-04-15/">MySQL面试题总结</a>
          </li>
        
          <li>
            <a href="/2017/04/09/2017-04-09/">MySQL常用优化指南，及大表优化思路</a>
          </li>
        
          <li>
            <a href="/2017/04/08/2017-04-08/">MySQL 学习笔记</a>
          </li>
        
          <li>
            <a href="/2017/04/02/2017-04-02/">Java 基础学习总结和学习路线规划</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 OuyangWenyuan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>